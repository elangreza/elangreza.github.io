---
title: "Strategy of Choosing the Locks"
publishedAt: "2026-01-15T21:11:52+07:00"
summary: "Strategy of Choosing the Locks"
active: "true"
tags: locks
---

Choosing the right locking strategy in microservices is critical for data integrity and performance. It often depends heavily on your specific use case, traffic patterns, and consistency requirements.

Here are the key criteria we usually consider:

1.  **Environment**: Must work across local, staging, and production.
2.  **Performance**: Should be fast and non-blocking where possible.
3.  **Scalability**: Must handle high traffic and concurrency.
4.  **Architecture**: Fits within a service/application layer, often interacting with an ACID database.

To simplify the decision-making process, we can categorize locks into four main types:

## 1. Application Locks

These locks exist purely within the application layer's memory. They are the fastest but also the most limited in scope.

**Concept**: A lock is held by a specific running instance of your application. It does _not_ synchronize across different replicas or pods.

**When to use**:

- Protecting in-memory shared resources (like a local cache).
- Coordinating background goroutines/threads within a single process.
- **NOT** for distributed systems where multiple instances need to coordinate.

**Code Example (Go)**:

```go
package main

import (
    "sync"
    "fmt"
)

type SafeCounter struct {
    mu sync.Mutex
    v  map[string]int
}

func (c *SafeCounter) Inc(key string) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.v[key]++
}
```

## 2. Optimistic Locks

Optimistic locking isn't strictly a "lock" but a versioning strategy. It assumes conflicts are rare.

**Concept**: You read a record along with a version number. When you update, you check if the version hasn't changed. If it has, the update fails, and you must retry or you ignore the update.

**When to use**:

- High read-to-write ratio.
- Low contention (updates to the same row are infrequent).
- When you want to avoid holding database connections open for long transactions.

**Code Example (SQL)**:

```sql
-- Step 1: Read current version
SELECT quantity, version FROM products WHERE id = 101;

-- Step 2: Application logic...

-- Step 3: Update only if version matches
UPDATE products
SET quantity = quantity - 1, version = version + 1
WHERE id = 101 AND version = 1;
```

## 3. Pessimistic Locks

Pessimistic locking prevents conflicts by ensuring only one transaction can access a record at a time.

**Concept**: You explicitly lock the row(s) in the database when you read them. Other transactions trying to acquire the same lock will wait until you commit or rollback.

**When to use**:

- High contention (many users trying to buy the last ticket).
- Critical data integrity where retries are expensive or difficult to implement.
- Preventing overselling in inventory systems.

**Code Example (SQL)**:

```sql
BEGIN;

-- Lock the row
SELECT * FROM products WHERE id = 101 FOR UPDATE;

-- Perform validation checks (e.g., is stock > 0?)
UPDATE products SET quantity = quantity - 1 WHERE id = 101;

COMMIT;
```

## 4. Distributed Locks

When your application runs on multiple servers (e.g., Kubernetes pods) and needs to coordinate access to a resource that isn't a database row (like a file, an external API, or a heavy computation).

**Concept**: Use a shared external store (Redis, ZooKeeper, etcd) to maintain a "lock" key.

**When to use**:

- Ensuring a scheduled job runs on only one pod.
- Rate limiting access to a third-party API across all instances.
- Operations that take a long time and shouldn't be repeated.

**Code Example (Redis/Pseudo-code)**:

```bash
# Try to set key 'my_lock' to 'unique_id'
# NX: Only set if not exists
# PX: Expire after 30000ms (30s) to prevent deadlocks if app crashes
SET my_lock unique_session_id NX PX 30000
```

## Summary

| Strategy    | Scope           | Best For           | Pros                          | Cons                                    |
| :---------- | :-------------- | :----------------- | :---------------------------- | :-------------------------------------- |
| Application | Single Instance | In-memory state    | Fastest, Simple               | Doesn't work in distributed apps        |
| Optimistic  | Database        | Low contention     | High concurrency, No blocking | Requires retry logic                    |
| Pessimistic | Database        | High contention    | Strong consistency            | Can cause deadlocks, reduced throughput |
| Distributed | Cluster         | External resources | Coordinates multiple services | Adds infrastructure dependency (Redis)  |
