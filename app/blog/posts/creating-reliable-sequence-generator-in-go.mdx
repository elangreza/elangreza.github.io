---
title: "Creating Reliable Sequence Generator"
publishedAt: "2026-01-18T08:00:00+07:00"
summary: "Creating Reliable Sequence Generator"
active: false
tags: go
---

In microservices, you often need unique, ordered IDs that survive crashes. The challenge: if your sequence service goes down, it must recover exactly where it left offâ€”not restart from zero.

In this post, we'll build a reliable sequence generator that handles this gracefully. We'll cover:

- Application in Go: using channels and go-routines for instant, concurrent-safe sequence generation
- SQLite3: persisting sequence values for crash recovery
- A Go server exposing the sequence endpoint using gorilla mux
- Unit and e2e tests to verify reliability

## Let's get started

### first step Choosing and Creating simple generator in Go

we will create the easy example, we will use odd numbers only.

the output will look like this:

```
1, 3, 5, 7, 9, ...
```

so we created the simple function `NextOdd`. The input is the last sequence, and add it with 2 so it's get the next odd number.

```go
func NextOdd(lastSeq int) int {
    return lastSeq + 2
}
```

and we create the sequence generator with FOC (first order function) style, so we get reserved next value

```go
func SequenceOdd() func() int {
    lastSeq := 0
    return func() int {
        lastSeq = NextOdd(lastSeq)
        return lastSeq
    }
}
```

and we grow the function with channel so we can reserve the value earlier. The channel itself have a blocking behavior so the response will be return exactly when we called the FOC function

```go
func SequenceOdd() func() int {
	lastSeq := 1

    // create unbuffered channel
	reservedInt := make(chan int)

    // spawn a go-routine
	go func() {
		for {
            // calculate next odd value
			reserved := NextOdd(lastSeq)

            // save a reserved value to channel
            // and the value will be block until the value FOC function is called
			reservedInt <- reserved

            // update the last sequence with the old reserved value, after FOC function is called
			lastSeq = reserved
		}
	}()

	return func() int {
		return <-reservedInt
	}
}
```

in the code above we use unbuffered channel to reserve a next sequence see `make(chan int)`

and we spawn a go routine and reserve the next value in the channel `reservedInt <- reserved`

we can get the next value with using `<-reservedInt`

and the `lastSeq` will be updated with the reserved value `lastSeq = reserved`

```go
import "fmt"

func main() {
    seq := SequenceOdd()
    fmt.Println(seq()) // will print 3 since we set the last sequence is 1
    fmt.Println(seq()) // will print 5
    fmt.Println(seq()) // will print 7
}

```
