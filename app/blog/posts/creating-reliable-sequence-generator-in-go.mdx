---
title: "Building a Reliable Sequence Generator in Go"
publishedAt: "2026-01-18T08:00:00+07:00"
summary: "How I built a crash-resilient, concurrent-safe sequence generator using Go, channels, and SQLite for microservices."
active: true
tags: go
---

When you're working with microservices, generating unique, ordered IDs that survive crashes is a surprisingly tricky problem. If your sequence service goes down, you canâ€™t just restart from zeroâ€”you need to pick up _exactly_ where you left off. Otherwise, you risk duplicate or out-of-order IDs, which can break data integrity.

I recently took on this problem and built a reliable sequence generator in Go. In this post, Iâ€™ll walk you through my approachâ€”step by stepâ€”including how I used:

- **Go routines and channels** for safe, concurrent sequence generation
- **SQLite** to persist the last-used value for crash recovery
- A lightweight **HTTP server** (with Gorilla Mux) to expose the sequence
- **Unit and end-to-end tests** to verify correctness under failure

But first, letâ€™s start simple.

---

## Step 1: A Basic Sequence Generator (Odd Numbers Only)

To keep things focused, I decided to generate only **odd numbers**: `1, 3, 5, 7, 9, ...`

I began with a tiny helper function that takes the last sequence number and returns the next odd one:

```go
func NextOdd(lastSeq int) int {
    return lastSeq + 2
}
```

Then, I wrapped this logic into a **closure**â€”a function that returns another function. This lets me encapsulate the internal state (`lastSeq`) without exposing it:

```go
func SequenceOdd() func() int {
    lastSeq := 0
    return func() int {
        lastSeq = NextOdd(lastSeq)
        return lastSeq
    }
}
```

This works fine for single-threaded use, but itâ€™s not safe for concurrent accessâ€”and it doesnâ€™t precompute the next value. So I took it a step further.

---

## Step 2: Adding Concurrency Safety with Channels

I wanted the generator to be both **concurrent-safe** and **responsive**. My solution? Use an **unbuffered channel** and a background goroutine to precompute the next sequence value.

Hereâ€™s how it works:

- A goroutine continuously calculates the next odd number.
- It sends that value into a channelâ€”but **blocks** until someone reads from it.
- When the caller invokes the returned function, it immediately receives the precomputed value.
- Only then does the generator update its internal state.

This ensures:

- No race conditions (thanks to channel synchronization)
- Zero allocation overhead on the hot path
- Exact resumption after any operation

Hereâ€™s the full implementation:

```go
func SequenceOdd() func() int {
    lastSeq := 1 // Start at 1 so the first call returns 3

    reservedInt := make(chan int) // Unbuffered channel

    go func() {
        for {
            reserved := NextOdd(lastSeq)
            reservedInt <- reserved   // Block until consumed
            lastSeq = reserved        // Update only after consumption
        }
    }()

    return func() int {
        return <-reservedInt
    }
}
```

Letâ€™s test it:

```go
import "fmt"

func main() {
    seq := SequenceOdd()
    fmt.Println(seq()) // 3
    fmt.Println(seq()) // 5
    fmt.Println(seq()) // 7
}
```

> ðŸ’¡ **Note**: I initialized `lastSeq` to `1`, so the first call returns `3`. If you want the sequence to start at `1`, just set `lastSeq = -1`.

---

## Step 3: Adding Persistent Storage with SQLite

To survive crashes or restarts, we need to persist the sequence state. I chose **SQLite** because itâ€™s:

- **Self-contained**: The database lives in a single file alongside your appâ€”no external dependencies.
- **Lightweight**: Easy to set up, copy, or back up.
- **Great for local testing**: No need to run a separate database server.

### Setting Up the Database

First, I created a simple helper to initialize the SQLite database and table:

```go
func setupDB() (*sql.DB, error) {
    db, err := sql.Open("sqlite3", "./seq.db")
    if err != nil {
        return nil, fmt.Errorf("failed to open database: %w", err)
    }

    if err := db.Ping(); err != nil {
        return nil, fmt.Errorf("failed to ping database: %w", err)
    }

    sqlStmt := `
        CREATE TABLE IF NOT EXISTS odd_sequence (
            id INTEGER PRIMARY KEY,
            created_at INTEGER
        );`

	_, err = db.Exec(sqlStmt)
	if err != nil {
		return nil, fmt.Errorf("failed to create table: %w", err)
	}

    return db, nil
}
```

> ðŸ›‘ **Note**: Make sure youâ€™ve imported the SQLite driver (e.g., `_ "github.com/mattn/go-sqlite3"`).

### Loading the Last Sequence on Startup

On startup, I query the database for the most recently generated ID. If none exists, I fall back to the initial value (`1`):

```go
// Load last sequence from DB
if err := db.QueryRow(`
    SELECT id FROM odd_sequence
    ORDER BY created_at DESC
    LIMIT 1
`).Scan(&lastSeq); err != nil {
    if err != sql.ErrNoRows {
        log.Fatal("failed to load last sequence:", err)
    }
    // If no rows, keep lastSeq = 1
}
```

### Persisting Every New Value

Every time a new sequence number is consumed, I insert it into the table:

```go
_, err := db.Exec("INSERT INTO odd_sequence (id, created_at) VALUES (?, ?)", lastSeq, time.Now().UnixMicro())
if err != nil {
    log.Fatal("failed to save sequence to DB:", err)
}
```

Putting it all together:

```go
func SequenceOdd(db *sql.DB) func() int {
    lastSeq := 1

    // Load last sequence from DB
    if err := db.QueryRow(`
        SELECT id FROM odd_sequence
        ORDER BY created_at DESC
        LIMIT 1
    `).Scan(&lastSeq); err != nil {
        if err != sql.ErrNoRows {
            log.Fatal("failed to load last sequence:", err)
        }
        // If no rows, keep lastSeq = 1
    }

    reservedInt := make(chan int)

    go func() {
		for {
			lastSeq = NextOdd(lastSeq)
			// Persist the sequence
			_, err := db.Exec("INSERT INTO odd_sequence (id, created_at) VALUES (?, ?)", lastSeq, time.Now().UnixMicro())
			if err != nil {
				log.Fatal("failed to save sequence to DB:", err)
			}
			reservedInt <- lastSeq
		}
	}()

    return func() int {
        return <-reservedInt
    }
}
```

### Testing Crash Recovery

Hereâ€™s the updated `main` function:

```go
package main

import (
	"database/sql"
	"fmt"
	_ "github.com/mattn/go-sqlite3"
)

func main() {
    db, err := setupDB()
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()

    seq := SequenceOdd(db)
    fmt.Println(seq())
    fmt.Println(seq())
    fmt.Println(seq())
}
```

Now, if I run the program twice:

```sh
$ go run main.go
3
5
7

$ go run main.go
9
11
13
```

It correctly resumes from where it left offâ€”because the last used ID is stored in `seq.db`.
